# Super Safe RSA 2

__PROBLEM__

Wow, he made the exponent really large so the encryption MUST be safe, right?! Connect with nc 2018shell1.picoctf.com 56543.

__HINT__

What is the usual value for e?

__SOLUTION__

>c: 70095824031398115323834909469137841876240658160634746495256586189274562210952060250230733744384126142754169157833572062924797070154772555706615790959809479493544730044024619417310115169889562716310571606009618977785611965096399007915142427689435281504641794370564326559384013648852734806063952099097063168047
n: 119207591973365178747178653348405617885287791682800338667456277216670787367741579921790086796345016682571874846236537674510970266025433406272386470732217970658003455664567846051113775420273159648646292158707411247469063951779747693627629660549528473212686239102360316654713614386340827450729337535128872617947
e: 96912896536931759519808331940782326333645628284169279097335405192551071165193270644566822169297686632702587726131539852265811614413767671486225356067756722358522438814082395028115271425626237984080999533399788230874076372085981958016325957472175993044163789944548164700317744977157824749534219440073076301313

Now the problem with this is that value of e is as big as the value of n. what's wrong with that? well [this](https://en.wikipedia.org/wiki/Wiener%27s_attack) is wrong with that. Basically we can just get the value of `d` by trying [`continued fraction`](https://en.wikipedia.org/wiki/Continued_fractions). And if we'll have the value of `d` then we can get plaintext by doing `pow(c,d,n)`.

So we go looking for some good weiner attack code and we got it. Just put the value of n and e in variable `e` and `n` in [this](./weiner.py) code.

From this we get `d` then `pow(c,d,n)`
Then decimal-hex-ascii.

FLAG - `picoCTF{w@tch_y0ur_Xp0n3nt$_c@r3fu11y_2104643}`
